/**
 * Utility function to generate responsive image markup with WebP support
 * 
 * @param {string} imagePath - Base path to the image (without extension)
 * @param {string} alt - Alt text for the image
 * @param {Object} options - Additional options
 * @param {string} options.className - CSS class name
 * @param {string} options.loading - Loading attribute ('lazy' or 'eager')
 * @param {string} options.sizes - Sizes attribute for responsive images
 * @param {number[]} options.widths - Array of responsive widths (default: [320, 640, 768, 1024, 1280, 1920])
 * @returns {string} HTML markup for responsive image
 */
export function generateResponsiveImage(imagePath, alt, options = {}) {
  const {
    className = '',
    loading = 'lazy',
    sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 80vw, 1200px',
    widths = [320, 640, 768, 1024, 1280, 1920],
  } = options;

  // Extract base path and determine format
  const basePath = imagePath.replace(/\.(jpg|jpeg|png|webp)$/i, '');
  const isWebP = imagePath.toLowerCase().endsWith('.webp');
  const originalExt = imagePath.match(/\.(jpg|jpeg|png|webp)$/i)?.[1] || 'jpg';
  
  // Generate srcset for WebP
  const webpSrcset = widths
    .map(width => `${basePath}-${width}w.webp ${width}w`)
    .join(', ');
  
  // Generate srcset for fallback format
  const fallbackSrcset = widths
    .map(width => `${basePath}-${width}w.${originalExt} ${width}w`)
    .join(', ');
  
  // Default src (largest size)
  const defaultSrc = `${basePath}.${originalExt}`;
  const defaultWebP = `${basePath}.webp`;

  return `
    <picture>
      <source 
        srcset="${webpSrcset}" 
        sizes="${sizes}" 
        type="image/webp"
      >
      <source 
        srcset="${fallbackSrcset}" 
        sizes="${sizes}" 
        type="image/${originalExt === 'jpg' ? 'jpeg' : originalExt}"
      >
      <img 
        src="${defaultSrc}" 
        srcset="${fallbackSrcset}"
        sizes="${sizes}"
        alt="${alt.replace(/"/g, '&quot;')}" 
        class="${className}"
        loading="${loading}"
        decoding="async"
      >
    </picture>
  `.trim();
}

/**
 * Generate responsive image markup for build-time (uses Vite asset handling)
 * This version works with Vite's asset processing and hash generation
 * 
 * @param {string} imagePath - Path to image in assets/images
 * @param {string} alt - Alt text
 * @param {Object} options - Options
 * @returns {string} HTML markup
 */
export function generateResponsiveImageBuild(imagePath, alt, options = {}) {
  const {
    className = '',
    loading = 'lazy',
    sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 80vw, 1200px',
  } = options;

  // For build-time, we'll use a simpler approach with srcset
  // The build process will generate the responsive sizes
  const basePath = imagePath.replace(/\.(jpg|jpeg|png|webp)$/i, '');
  const originalExt = imagePath.match(/\.(jpg|jpeg|png|webp)$/i)?.[1] || 'jpg';
  
  // In production, use the optimized versions generated by the build
  // For now, we'll use a pattern that works with the build plugin
  const widths = [320, 640, 768, 1024, 1280, 1920];
  
  const webpSrcset = widths
    .map(width => `${basePath}-${width}w.webp ${width}w`)
    .join(', ');
  
  const fallbackSrcset = widths
    .map(width => `${basePath}-${width}w.${originalExt} ${width}w`)
    .join(', ');

  return `
    <picture>
      <source 
        srcset="${webpSrcset}" 
        sizes="${sizes}" 
        type="image/webp"
      >
      <source 
        srcset="${fallbackSrcset}" 
        sizes="${sizes}" 
        type="image/${originalExt === 'jpg' ? 'jpeg' : originalExt}"
      >
      <img 
        src="${basePath}.${originalExt}" 
        srcset="${fallbackSrcset}"
        sizes="${sizes}"
        alt="${alt.replace(/"/g, '&quot;')}" 
        class="${className}"
        loading="${loading}"
        decoding="async"
      >
    </picture>
  `.trim();
}

